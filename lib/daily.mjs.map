{
  "version": 3,
  "sources": ["../src/daily.ts"],
  "sourcesContent": ["#!/usr/bin/env /usr/local/bin/node\n\nimport { FileHandle, open, writeFile, readdir, rename} from \"node:fs/promises\";\nimport { parseArgs, ParseArgsConfig } from \"node:util\";\nimport path from \"path\";\nimport { format, subDays, differenceInDays, parse } from \"date-fns\";\n\nconst __filename = process.cwd();\nconst now = new Date();\n\nconst doneRegex = /^.+(\u2714|- \\[x\\]).+\\n/gmu;\n\nconst dateRegex = /\\d{2,4}-\\d{2}-\\d{2}/;\n\nconst fmtString = \"yyyy-MM-dd\";\nfunction fmtDate(d: Date) {\n  return format(d, fmtString);\n}\n\nfunction parseDate(s: string) {\n  return parse(s, fmtString, new Date())\n}\nconst helpDocs = `\nCopies todo items from previous daily file to today's new file.\n\nUsage: daily [options]\n  -a --archive    Archive files from previous weeks into '[dir]/Archive' dir\n\t-d --dir\t\t\t\tDirectory for your daily files (default is '../').\n\t-o --overwrite  Should it overwrite the today file if it already exists?\n\t-e --ext\t\t\t\tFile extension (default is '.taskpaper').\n\t-n --days\t\t\t\tDays back to search for previous daily file (default 100).\n\t-h --help\t\t\t\tPrints this help.\n`;\n\n\nconst args: ParseArgsConfig = {\n  options: {\n    dir: {\n      type: \"string\",\n      short: \"d\",\n      default: \"../\",\n    },\n    overwrite: {\n      type: \"boolean\",\n      short: \"o\",\n      default: false,\n    },\n    extension: {\n      type: \"string\",\n      short: \"e\",\n      default: \".taskpaper\",\n    },\n    days: {\n      type: \"string\",\n      short: \"n\",\n      default: \"100\",\n    },\n    archive: {\n      type: \"boolean\",\n      short: \"a\",\n      default: false,\n    },\n    help: {\n      type: \"boolean\",\n      short: \"h\",\n      default: false,\n    },\n  },\n};\nconst {\n  values: { archive, dir, overwrite, extension, help, days },\n} = parseArgs(args);\nlet n = 100;\nif (typeof days === \"string\") {\n  n = Number.parseInt(days);\n}\nconst directory = typeof dir === \"string\" ? dir : \"../\";\nconst archiveDir = path.resolve(`${directory}/Archive`)\nconst fileExtension = typeof extension === \"string\" ? extension : \".taskpaper\";\n\n/**\n * Copies contents from given file, cleans the text, and writes to file with\n * todays date in the filename.\n * @param  {FileHandle} file [the existing file to read from]\n * @return {Promise}      Resolves when new file is written\n */\nasync function copyToNewFile(file: FileHandle): Promise<any> {\n  const { buffer } = await file.read();\n  console.log(\"Copied previous file...\");\n  const contents = buffer.toString();\n  console.log(contents.length);\n  let newContents = contents.replace(doneRegex, \"\");\n  const journalIndex = newContents.indexOf(\"# JOURNAL\");\n  if (journalIndex > 0) {\n    newContents = newContents.substring(0, journalIndex + 9);\n    newContents = `${newContents}\\r\\n#######################################`;\n  }\n  console.log(newContents.length);\n  const todayFile = path.resolve(\n    __filename,\n    `${directory}${fmtDate(now)}${fileExtension}`\n  );\n  if (!overwrite) {\n    let existingFile;\n    try {\n      existingFile = await open(todayFile);\n    } catch {\n      //continue\n    }\n    if (existingFile) {\n      throw new Error(\"File exists, and overwrite option was not set.\");\n    }\n  }\n  console.log(\"Writing new file:\", todayFile);\n  await writeFile(todayFile, newContents);\n  if (archive) {\n    const oldDate = subDays(new Date(), 7);\n    console.log(\"Looking for files to archive older than \", oldDate);\n    const archivable = await getArchivableFiles(oldDate);\n    if (archivable && archivable.length) {\n      await archiveFiles(archivable)\n      console.log(\"Moving old files to ./Archive complete.\")\n    }\n\n  }\n}\n\n/**\n * Attempts to open the daily file from yesterday and recursively looks\n * back 1 day at a time until it finds a file.\n * @return {[Promise]} [Resolves when it finds and writes a file or rejects\n * if no file is found for the last 'n' days.]\n */\nasync function openLastFile() {\n  /**\n   * Recursive function that gets date - x days and attempts to open it\n   * @param  {Date} date        \t\tThe date to start with\n   * @param  {Number} subtraction \tNumber of days to subtract from date, defaults to 1\n   * @return {Promise}     \t\t\t\t\tA promise that resolves when find and copy\n   * succeeds or rejects when no file can be found\n   */\n  async function getPreviousPath(\n    date: Date,\n    subtraction: number = 1\n  ): Promise<void> {\n    const newDate = subDays(date, subtraction);\n\n    const filePath = path.resolve(\n      __filename,\n      `${directory}${fmtDate(newDate)}${fileExtension}`\n    );\n    console.log(\"Looking for most recent file...\");\n    try {\n      const file = await open(filePath);\n      console.log(\"Found file and opening:\", filePath);\n      return copyToNewFile(file);\n    } catch (reason) {\n      console.log(\"Unable to open file: \", filePath);\n      if (differenceInDays(now, newDate) > n) {\n        throw new Error(\n          `Looked back ${n} days without finding a daily ${fileExtension} file in ${directory}, giving up.`\n        );\n      }\n      return getPreviousPath(newDate);\n    }\n  }\n\n  return getPreviousPath(now);\n}\n\nasync function archiveFiles(fileNames: string[]) {\n  return Promise.all(\n    fileNames.map((name) => {\n      console.log(\"moving...\", name)\n      return rename(path.resolve(directory, name), path.resolve(archiveDir, name))\n    })\n  )\n}\n\nasync function getArchivableFiles(olderThan: Date): Promise<string[] | undefined> {\n  function isOld(fileDate: Date) {\n    return fileDate < olderThan;\n  }\n  const allFiles = await readdir(path.resolve(directory));\n  const taskFiles = allFiles.filter((name: string) => path.extname(name) === fileExtension)\n  const oldFiles = taskFiles.filter((name: string) => {\n    const file = path.basename(name, fileExtension);\n    // console.log(\"old file\", file);\n    if (dateRegex.test(file)) {\n      // console.log(\"regex matched\");\n      const fileDate = parseDate(file);\n      // console.log('parsedate result', fileDate);\n      return typeof fileDate === \"object\" && isOld(fileDate);\n    } else {\n      // console.log(\"regex not matched!\", file);\n      return false;\n    }\n  })\n  console.log(\"Found files to archive:\", oldFiles.length);\n  return oldFiles;\n}\n\nif (help) {\n  console.log(helpDocs);\n} else {\n  openLastFile()\n    .catch((error) => {\n      console.error(error);\n      process.exit(1);\n    })\n    .then(() => {\n      console.log(\"Finished\");\n      process.exit(0);\n    });\n}\n"],
  "mappings": "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",
  "names": []
}
